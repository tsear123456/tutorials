# Goal

It's possible to validate data sent to Webcom by using security rules.

Let's revisit our chat sample in [exercise 2](https://github.com/webcom-components/tutorials/blob/master/ex2/README.md) and validation constraints.

# Create a namespace if needed

If you don't have a namespace, follow [exercise 0](https://github.com/webcom-components/tutorials/blob/master/ex0/README.md) to create it.

# Security rules

Let's start from exercise 2 [code base](https://jsbin.com/tevovo/edit?js,output)

To enable chat, uncomment the first line 

```javascript
// var ref = new Webcom('https://webcom.orange.com/base/<YOUR NAMESPACE>');
```

And replace token `<YOUR NAMESPACE>` by your namespace

Now, go to your dashboard and manage your namespace.

Click on security tab. 

![security tab](https://raw.githubusercontent.com/webcom-components/tutorials/master/ex3/security.png)

This page helps you to edit security rules on your data. 
It's possible to add validation constraints and rules that must be verified to read or write data. 
For example, it's useful to restrict access to specific users , watch out [exercise 4](https://github.com/webcom-components/tutorials/blob/master/ex4/README.md) if you are interested.

If you need to better understand security rules, read this [article](https://webcom.orange.com/doc/tutorial-rules-validation.html)

By default, security rules are very permissive.

```json
{
  "rules": {
    ".read": true,
    ".write": true
  }
}
```

Everyone can read and write data anywhere into namespace

# Add a validation constraint

Let's add a validation constraint only for messages :
 
Message can only have key named `name` and `text`

```json
{
  "rules": {
    ".read": true,
    ".write": true,
    "messages": {
      "$message": {
      	"name" : { ".validate": true },
      	"text" : { ".validate": true },
		"$other" : { ".validate": false }
      }
    }
  }
}
```

First, we added a key `"messages": { ... }`. It targets the node where we want to apply our rules.

Into `messages`, we added `"$message": { ... }`. 
We used `$` character followed by `message` to match any child node of `messages` and store it's name into `$message` variable.
It's useful when you don't know key name, specially those generated by [push()](https://webcom.orange.com/doc/Webcom.html#push) calls.

For each `$message`, we validate `name` and `text` key names with `{ ".validate": true }` and nothing more with 
`"$other" : { ".validate": false }`

Click on save button to confirm new rules.

# Test our rule

Return to your JS Bin, and edit `send()` method like this :

```javascript
function send() {
  if (!msgText.value) {
    return;
  }
  if ((event.type === 'keypress' && 
      event.keyCode === 13) || event.type === 'click') {
    ref.child('messages').push({
      name: nickname.value || 'anonymous',
      text: msgText.value,
      foo: 'bar' // Line added
    }, function() {
      console.log('after push', arguments);
    });
    msgText.value = '';    
  }
}
```

We pushed a new key/value `foo` for each new message. If we send a new message, it will breaks our rule.

To check this, open the console tab in JS Bin and send a new message. It prints this kind of message:

```
"WEBCOM WARNING: set at /messages/-K29TWLWYPrzj5gMZPj9 failed: permission_denied "
```

You notice also new message is displayed in chat. It's weird ! Why ? 
 
It's because data is set at first on client and after pushed to Webcom namespace. Rules are executed only on server-side.

Once rules executed, server send reverse action to client to revert action. 
For our chat action, it triggers 'child_removed' event on `messages` node.
Go to listen this event and remove message:

```javascript
ref.child('messages').on('child_removed', function (snap) {
	var id = snap.name();
  	var m = document.querySelector('li[id="'+id+'"]');
  	messagesList.removeChild(m);
});
```

When event is fired, first, we get snapshot key generated by [push()](https://webcom.orange.com/doc/Webcom.html#push) method.
And we just have to find an list item with this value as id and remove it from the list.

Now, try to add a new message. It will appears and disappears just after ! 

To avoid this flickering effect, you can also add the list item after push confirmation sent by server.
[push()](https://webcom.orange.com/doc/Webcom.html#push) accepts a callback as second argument, which is called after rules are validated.
The downside of the technique is you will loose user interface reactivity. 
Maybe, the best solution is to validate data before sending it to the server ...

# Final result

Check final result [here](https://jsbin.com/peneve/edit?js,console,output)

To enable chat, uncomment the first line 

```javascript
// var ref = new Webcom('https://webcom.orange.com/base/<YOUR NAMESPACE>');
```

And replace token `<YOUR NAMESPACE>` by your namespace